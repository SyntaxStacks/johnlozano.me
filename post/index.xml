<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Post-rsses on John Lozano</title>
    <link>http://syntaxstacks.github.io/post/index.xml</link>
    <description>Recent content in Post-rsses on John Lozano</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 27 Nov 2016 15:43:52 -0600</lastBuildDate>
    <atom:link href="http://syntaxstacks.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Configuring i3</title>
      <link>http://syntaxstacks.github.io/post/configuring-i3/</link>
      <pubDate>Sun, 27 Nov 2016 15:43:52 -0600</pubDate>
      
      <guid>http://syntaxstacks.github.io/post/configuring-i3/</guid>
      <description>

&lt;p&gt;As a developer, focus is key. An environment with minimal distractions is conducive to productivity and window managers offer minimalist user interfaces in place of the traditional desktop environment. i3 on Ubuntu will be discussed here but there are alternate window managers such as &lt;a href=&#34;http://dwm.suckless.org/&#34;&gt;dwm&lt;/a&gt; and &lt;a href=&#34;https://awesome.naquadah.org/&#34;&gt;awesome&lt;/a&gt;. i3 can be installed with the following command:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install i3
sudo apt-get install i3
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;i3-configuration&#34;&gt;i3 Configuration&lt;/h2&gt;

&lt;p&gt;i3’s configuration should be created in &lt;code&gt;~/.config/i3/config&lt;/code&gt;. Here is the default configuration from the man page:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# i3 config file (v4)

# Font for window titles. Will also be used by the bar unless a different font
# is used in the bar {} block below.
# This font is widely installed, provides lots of unicode glyphs, right-to-left
# text rendering and scalability on retina/hidpi displays (thanks to pango).
font pango:DejaVu Sans Mono 8
# Before i3 v4.8, we used to recommend this one as the default:
# font -misc-fixed-medium-r-normal--13-120-75-75-C-70-iso10646-1
# The font above is very space-efficient, that is, it looks good, sharp and
# clear in small sizes. However, its unicode glyph coverage is limited, the old
# X core fonts rendering does not support right-to-left and this being a bitmap
# font, it doesn&#39;t scale on retina/hidpi displays.

# use Mouse+Mod1 to drag floating windows to their wanted position
floating_modifier Mod1

# start a terminal
bindsym Mod1+Return exec /usr/bin/urxvt

# kill focused window
bindsym Mod1+Shift+q kill

# start dmenu (a program launcher)
bindsym Mod1+d exec /usr/bin/dmenu_run

# change focus
bindsym Mod1+j focus left
bindsym Mod1+k focus down
bindsym Mod1+l focus up
bindsym Mod1+semicolon focus right

# alternatively, you can use the cursor keys:
bindsym Mod1+Left focus left
bindsym Mod1+Down focus down
bindsym Mod1+Up focus up
bindsym Mod1+Right focus right

# move focused window
bindsym Mod1+Shift+j move left
bindsym Mod1+Shift+k move down
bindsym Mod1+Shift+l move up
bindsym Mod1+Shift+semicolon move right

# alternatively, you can use the cursor keys:
bindsym Mod1+Shift+Left move left
bindsym Mod1+Shift+Down move down
bindsym Mod1+Shift+Up move up
bindsym Mod1+Shift+Right move right

# split in horizontal orientation
bindsym Mod1+h split h

# split in vertical orientation
bindsym Mod1+v split v

# enter fullscreen mode for the focused container
bindsym Mod1+f fullscreen toggle

# change container layout (stacked, tabbed, default)
bindsym Mod1+s layout stacking
bindsym Mod1+w layout tabbed
bindsym Mod1+e layout default

# toggle tiling / floating
bindsym Mod1+Shift+space floating toggle

# change focus between tiling / floating windows
bindsym Mod1+space focus mode_toggle

# focus the parent container
bindsym Mod1+a focus parent

# focus the child container
#bindsym Mod1+d focus child

# switch to workspace
bindsym Mod1+1 workspace 1
bindsym Mod1+2 workspace 2
# ..

# move focused container to workspace
bindsym Mod1+Shift+1 move workspace 1
bindsym Mod1+Shift+2 move workspace 2
# ...

# reload the configuration file
bindsym Mod1+Shift+c reload
# restart i3 inplace (preserves your layout/session, can be used to upgrade i3)
bindsym Mod1+Shift+r restart
# exit i3 (logs you out of your X session)
bindsym Mod1+Shift+e exit

# display workspace buttons plus a statusline generated by i3status
bar {
      status_command i3status
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;link rel=&#34;stylesheet&#34; type=&#34;text/css&#34; href=&#34;https://maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css&#34;&gt;
&lt;style&gt;
  code {
    font-family: Inconsolata, monospace, sans-serif, FontAwesome;
  }
&lt;/style&gt;&lt;/p&gt;

&lt;h2 id=&#34;customization&#34;&gt;Customization&lt;/h2&gt;

&lt;p&gt;Customizations should be made in the &lt;code&gt;~/.config/i3/config&lt;/code&gt; file.&lt;/p&gt;

&lt;h4 id=&#34;i3-status-bar&#34;&gt;i3 Status Bar&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;bar {
  status_command i3status
  font pango:Hack, FontAwesome 10
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;status_command receives json and parses output to the status bar in i3.
&lt;a href=&#34;https://github.com/LemonBoy/bar&#34;&gt;Lemonbar&lt;/a&gt; is another example of a status bar application that could be in place
of i3status.&lt;/p&gt;

&lt;h4 id=&#34;setting-a-background&#34;&gt;Setting a Background&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;feh&lt;/code&gt; can be used to set the background for i3. Install &lt;code&gt;feh&lt;/code&gt; with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install feh to managed backgrounds
sudo apt-get install feh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With &lt;code&gt;feh&lt;/code&gt; installed, add the following line to i3&amp;rsquo;s config&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;exec --no-startup-id feh --bg-scale /path/to/awesome/wallpaper.png
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;audio-keys&#34;&gt;Audio Keys&lt;/h4&gt;

&lt;p&gt;The following configurations can be added to enable audio keys.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bindsym XF86AudioLowerVolume    exec $psst pactl set-sink-volume @DEFAULT_SINK@ -5% &amp;amp;&amp;amp; pactl set-sink-mute @DEFAULT_SINK@ 0 $update
bindsym XF86AudioRaiseVolume    exec $psst pactl set-sink-volume @DEFAULT_SINK@ +5% &amp;amp;&amp;amp; pactl set-sink-mute @DEFAULT_SINK@ 0 $update
bindsym XF86AudioMute           exec $psst pactl set-sink-mute @DEFAULT_SINK@ toggle $update
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;screen-brightness&#34;&gt;Screen Brightness&lt;/h4&gt;

&lt;p&gt;The following configurations can be added to enable brightness keys.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bindsym XF86MonBrightnessDown   exec xbacklight -dec 10
bindsym XF86MonBrightnessUp     exec xbacklight -inc 10
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;print-screen&#34;&gt;Print Screen&lt;/h4&gt;

&lt;p&gt;The following configurations can be added to enable print screen. &lt;code&gt;scrot&lt;/code&gt; is used in this example. Be sure to install &lt;code&gt;scrot&lt;/code&gt; when using this configuration.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# install scrot if not installed
sudo apt-get install scrot

# ~/.config/i3/config
# Print screen focused window
bindsym Print exec scrot -u &#39;%Y%m%d_%H%M%S.png&#39; -e &#39;mv $f ~/Pictures/shots/&#39;

# Print screen entire view
bindsym $mod+Print exec scrot &#39;%Y%m%d_%Ho%M%S.png&#39; -e &#39;mv $f ~/Pictures/shots/&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;configuring-i3status&#34;&gt;Configuring i3status&lt;/h2&gt;

&lt;p&gt;&lt;code&gt;i3status&lt;/code&gt; handles the status bar output. The config file for &lt;code&gt;i3status&lt;/code&gt; is located in &lt;code&gt;~/.i3status.conf&lt;/code&gt;. Here is an example config that uses &lt;a href=&#34;http://fontawesome.io/&#34;&gt;FontAwesome&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# i3status configuration file.
# see &amp;quot;man i3status&amp;quot; for documentation.

# It is important that this file is edited as UTF-8.
# The following line should contain a sharp s:
# ß
# If the above line is not correctly displayed, fix your editor first!

general {
        colors = true
        interval = 5
}

order += &amp;quot;disk /&amp;quot;
order += &amp;quot;volume master&amp;quot;
order += &amp;quot;wireless _first_&amp;quot;
order += &amp;quot;battery 1&amp;quot;
order += &amp;quot;load&amp;quot;
order += &amp;quot;tztime local&amp;quot;

wireless _first_ {
        format_up = &amp;quot; (%essid - %quality) %ip&amp;quot;
        format_down = &amp;quot;down&amp;quot;
}

volume master {
        format = &amp;quot; %volume&amp;quot;
        format_muted = &amp;quot; (%volume)&amp;quot;
        device = &amp;quot;pulse:1&amp;quot;
        mixer = &amp;quot;Master&amp;quot;
        mixer_idx = 0
}

battery 1 {
        format = &amp;quot;%status %percentage %remaining&amp;quot;
        status_bat = &amp;quot;&amp;quot;
        status_chr = &amp;quot;&amp;quot;
        status_full = &amp;quot;&amp;quot;
        low_threshold = 30
        threshold_type = percentage
        integer_battery_capacity = true
        color_good = &amp;quot;#0000FF&amp;quot;
}

run_watch DHCP {
        pidfile = &amp;quot;/var/run/dhclient*.pid&amp;quot;
}

run_watch VPN {
        pidfile = &amp;quot;/var/run/vpnc/pid&amp;quot;
}

tztime local {
        format = &amp;quot; %h %d, %Y %I:%M:%S&amp;quot;
}

load {
        format = &amp;quot; %1min&amp;quot;
}

disk &amp;quot;/&amp;quot; {
        format = &amp;quot; %avail&amp;quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;i3 is relatively straight forward to setup given the user reads the man page. It will be interesting to dive into research for other status bars, but for now it&amp;rsquo;s time to get back to work.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Testing Spree Commerce with RSpec</title>
      <link>http://syntaxstacks.github.io/post/testing-spree-commerce-with-rspec/</link>
      <pubDate>Sat, 12 Nov 2016 11:08:56 -0600</pubDate>
      
      <guid>http://syntaxstacks.github.io/post/testing-spree-commerce-with-rspec/</guid>
      <description>

&lt;p&gt;Spree commerce is a rails plugin that allows users to stand up their own ecommerce platform.
I am currently working on a project that will integrate a drop shipping API with spreee commerce
and insist on testing my work to prevent regressions moving forward. The current issue that
I am solving for is to send an order to the drop shipper via an API call upon completion of an order.
The API call has been encapsulated in a method named &lt;code&gt;submit_order_to_printful&lt;/code&gt; on the &lt;code&gt;Spree::Order&lt;/code&gt; model and a test is needed to validate
that the method is being called when we are expecting it to be.&lt;/p&gt;

&lt;h2 id=&#34;testing-with-rspec&#34;&gt;Testing with RSpec&lt;/h2&gt;

&lt;h6 id=&#34;spec-models-order-decorator-spec-rb&#34;&gt;spec/models/order_decorator_spec.rb&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;require &#39;rails_helper&#39;

# Turn off the job queue
Delayed::Worker.delay_jobs = false

describe Spree::Order, type: :model do
  let(:order) { FactoryGirl.create(:order_with_line_items)}
  before do
    allow(order).to receive(:require_email)
    allow(Spree::Order.printful_api).to receive(:post)
  end

  context &amp;quot;when current state is confirm&amp;quot; do
    before do
      order.state = &amp;quot;confirm&amp;quot;

      # Mocking Spree::Order checkout_flow requirements
      allow(order).to receive_messages payment_required?: true
      allow(order).to receive_messages process_payments!: true
      allow(order).to receive_messages confirmation_delivered?: true
    end

    context &amp;quot;when payment processing succeeds&amp;quot; do
      before do
        order.payments &amp;lt;&amp;lt; FactoryGirl.create(:payment, state: &#39;checkout&#39;, order: order)
      end

      it &amp;quot;should submit order to printful&amp;quot; do
        expect(Spree::Order).to receive(:submit_order_to_printful)
        order.next!
        expect(order.state).to eq(&#39;complete&#39;)
      end
    end
  end
end

&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We start by disabling &lt;a href=&#34;https://github.com/tobi/delayed_job&#34;&gt;DelayedJob&lt;/a&gt; for testing purposes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;require &#39;rails_helper&#39;

# Turn off job queue
Delayed::Worker.delay_jobs = false
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the order state is set to &lt;code&gt;confirm&lt;/code&gt;. The &lt;a href=&#34;https://github.com/spree/spree/blob/master/core/app/models/spree/order.rb#L46-L53&#34;&gt;Checkout Flow&lt;/a&gt;
for the Order model in spree requires a few conditions at various points during the checkout.
We can force the flow of the checkout by mocking the conditions require for completion.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;order.state = &amp;quot;confirm&amp;quot;

# Mocking Spree::Order checkout_flow requirements
allow(order).to receive_messages payment_required?: true
allow(order).to receive_messages process_payments!: true
allow(order).to receive_messages confirmation_delivered?: true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That will allow us to test the logic of the checkout process in isolation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;context &amp;quot;when payment processing succeeds&amp;quot; do
  before do
    order.payments &amp;lt;&amp;lt; FactoryGirl.create(:payment, state: &#39;checkout&#39;, order: order)
  end

  it &amp;quot;should submit order to printful&amp;quot; do
    expect(Spree::Order).to receive(:submit_order_to_printful)
    order.next!
    expect(order.state).to eq(&#39;complete&#39;)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We add a fake payment to the order and then start our assertions and actions. &lt;code&gt;order.next!&lt;/code&gt; steps the
&lt;code&gt;complete&lt;/code&gt; state and we can expect that the &lt;code&gt;submit_order_to_printful&lt;/code&gt; method is called.&lt;/p&gt;

&lt;h2 id=&#34;the-code&#34;&gt;The Code&lt;/h2&gt;

&lt;p&gt;The code to implement the hook is simple&lt;/p&gt;

&lt;h6 id=&#34;app-models-spree-order-decorator-rb&#34;&gt;app/models/spree/order_decorator.rb&lt;/h6&gt;

&lt;pre&gt;&lt;code&gt;Spree::Order.class_eval do
  include PrintfulConcern

  state_machine.after_transition :to =&amp;gt; :complete do |order|
    Spree::Order.submit_order_to_printful(order)
  end
end
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;PrintfulConcern&lt;/code&gt; contains the integration to the printful api and adds &lt;code&gt;submit_order_to_printful&lt;/code&gt;
method to the Spree:Order class. With that we add logic to the &lt;code&gt;complete&lt;/code&gt; state&amp;rsquo;s after_transition hook
and pass the order information to the method.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;Now that we have the functionality implemented and tested, we can place orders in spree and see orders populated
in Printfuls control panel. The work we have today will work tomorrow, and when it doesn&amp;rsquo;t, we will know.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>